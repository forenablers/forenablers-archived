{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/facebook-hackercup2018/",
    "result": {"data":{"site":{"siteMetadata":{"title":"For Enablers"}},"markdownRemark":{"id":"cf8821a9-8f27-51a3-afb1-5676377024a0","excerpt":"It is always interesting to measure your skills in problem solving. One of the ways to check how good you are, is to participate in Facebook Hackercup. If you…","html":"<p>It is always interesting to measure your skills in problem solving. One of the ways to check how good you are, is to participate in Facebook Hackercup. If you consider participating next year - I’d like to share my top 5 learnings from this year.</p>\n<h3>1. Train yourself to understand challenge quickly</h3>\n<p>Challenges’ descriptions are huge. You have to be very attentive to get it right. After the problem is understood, it needs to be translated into a technical problem. You can train this skill using the <a href=\"https://www.facebook.com/hackercup/past_rounds/1825579961046099/\">challanges from previous years</a>.</p>\n<h3>2. Solve without coding first</h3>\n<p>Every challenge has a sample input and output. Use this information. Although it is tempting to start coding right away, try to solve it step by step on paper or on a white board. Make sure that you have the same output.</p>\n<p>This approach will help you to see patterns or even to find a simple solution. For example here is one of the challenges:</p>\n<blockquote>\n<p>Consider an N-degree polynomial, expressed as follows:</p>\n<p>$$P_N * x^N + P_N-1 * x^N-1 + … + P_1 * x^1 + P_0 * x^0$$</p>\n<p>You’d like to find all of the polynomial’s $x$ (\nall distinct real values of $x$ for which the expression evaluates to $0$).</p>\n<p>The order of operations has been reversed: Addition ($+$) now has\nthe highest precedence, followed by multiplication ($*$), followed by exponentiation (^).</p>\n<p>Constraints: $P_N ≠ 0$</p>\n</blockquote>\n<p>After reading this you might think that this problem is somehow similar to <a href=\"https://en.wikipedia.org/wiki/3SUM\">3-sum problem</a>. However if you put it down on paper or whiteboard it will be obvious that the solution is quite simple:</p>\n<ul>\n<li>The polynomial can be evaluated to $0$ when $x = 0$ and polynomial’s degree is odd.</li>\n<li>Otherwise it cannot be evaluated to $0$.</li>\n</ul>\n<p>The code in the end will be simple:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">calculatePolynomialInterceptions</span><span class=\"token punctuation\">(</span>degree<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> degree <span class=\"token operator\">%</span> <span class=\"token number\">2</span> <span class=\"token operator\">!=</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token number\">0.0</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># the only possible solution</span>\n    <span class=\"token keyword\">else</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> <span class=\"token comment\"># no such x</span></code></pre></div>\n<details><summary>Explanation</summary>\n<p>\n<p>It might take some time to realise how a polynomial would look like after applying new operations order. Let’s start with $N=3$ and write the polynomial down:</p>\n<p>$P_3 * x$ ^ $3 + P_2 * x$ ^ $2 + P_1 * x$ ^ $1 + P_0 * x$ ^ 0</p>\n<p>According to the order of operations it should look as following:</p>\n<p>$(P_3 * x)$ ^ $((3 + P_2) * x)$ ^ $((2 + P_1) * x)$ ^ $((1 + P_0) * x)$ ^ $0$</p>\n<p>From that we can see that we have $(P_3 * x)$ as a base and the rest as an exponent. We will refer to the exponent as $a$:</p>\n<p>$a = ((3 + P_2) * x)$ ^ $((2 + P_1) * x)$ ^ $((1 + P_0) * x)$ ^ $0$</p>\n<p>and will get the expression:</p>\n<p>$$P_3 * x ^ a = 0$$</p>\n<p>Since $P_3 ≠ 0$ according to the problem description, the polynomial can be evaluated to $0$ only and only when $x = 0$ and $a ≠ 0$.</p>\n<p>We have found the $x$ and the only thing we need to do is to make sure that $a ≠ 0$, otherwise $P_3 * 0^0 = P_3$.</p>\n<p>Let’s take a look at $a$. Since $x = 0$, we will get:</p>\n<p>$a = ((3 + P_2) * 0)$ ^ $((2 + P_1) * 0)$ ^ $((1 + P_0) * 0)$ ^ $0$</p>\n<p>$a = 0$ ^ $0$ ^ $0$ ^ $0$</p>\n<p>$a = 1$</p>\n<p>The answer is that the <em>3rd-degree</em> polynomial does evaluate to $0$ only and only when $x = 0$. However if it would be <em>2nd-degree</em> polynomial, it does not evaluate to $0$ for any real value $x$:</p>\n<p>$a = 0$ ^ $0$ ^ $0$</p>\n<p>$a = 0$</p>\n<p>$P_2 * x^0 = P_2 * 1 = P_2 (≠ 0)$</p>\n<p>It turns out that the final solution of this problem is quite easy - we just need to check whether the polynomial degree is odd, and if it is so then it can be evaluated to $0$ when $x = 0$.</p>\n</p>\n</details>\n<h3>3. Use brute force and improve</h3>\n<p>Use a naive approach and solve a problem as quick as possible. Once you have a solution ask yourself following questions and try to improve these aspects if an answer is positive:</p>\n<ul>\n<li>Are there bottlenecks?</li>\n<li>Are there duplicated work?</li>\n<li>Are there useless work?</li>\n</ul>\n<h3>4. Solve and reverse engineer your thought process</h3>\n<p>Forget about your CS skills and try to solve a problem as a human or as a small kid. Got a solution? Reverse engineer your thought process and convert it into an algorithm.</p>\n<p>For example you are challenged:</p>\n<blockquote>\n<p>Given <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR)\">Pre-order</a> and <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\">In-order</a> traversals of a tree, reconstruct the tree.</p>\n<p>In-order: A, B, C, D, E, F, I, G, H</p>\n<p>Pre-order: F, B, A, D, C, E, G, I, H</p>\n</blockquote>\n<p>What you can try is to reconstruct the tree without thinking about algorithms, loops, recursions, stacks whatsoever.</p>\n<p>What we know is that in pre-order the left element is the root. Let’s draw the root:</p>\n<div class=\"gatsby-highlight\" data-language=\"mermaid\"><pre class=\"language-mermaid\"><code class=\"language-mermaid\"><span class=\"token keyword\">graph</span> TD<span class=\"token punctuation\">;</span>\n    F<span class=\"token text string\">((F))</span></code></pre></div>\n<p>Next root element is <code class=\"language-text\">B</code> but where to put it - we don’t know yet. Looking at the in-order traversal result, we can notice that <code class=\"language-text\">F</code> splits it into two: <code class=\"language-text\">A, B, C, D, E</code> and <code class=\"language-text\">I, G, H</code>.</p>\n<p>These are nodes that are on the left and on the right from our root <code class=\"language-text\">F</code>. Which nodes are children of <code class=\"language-text\">F</code>? The ones that come first in the pre-order - <code class=\"language-text\">B</code> and <code class=\"language-text\">G</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"mermaid\"><pre class=\"language-mermaid\"><code class=\"language-mermaid\"><span class=\"token keyword\">graph</span> TD<span class=\"token punctuation\">;</span>\n    F<span class=\"token text string\">((F))</span><span class=\"token arrow operator\">--></span>B<span class=\"token text string\">((B))</span><span class=\"token punctuation\">;</span>\n    F<span class=\"token arrow operator\">--></span>G<span class=\"token text string\">((G))</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Now <code class=\"language-text\">B</code> splits the in-order <code class=\"language-text\">A, B, C, D, E</code> into the only left child <code class=\"language-text\">A</code> and descendant ondes on the right <code class=\"language-text\">C, D, E</code>. Which node is the right child of <code class=\"language-text\">B</code>? The answer is <code class=\"language-text\">D</code>, since it comes first in the pre-order.</p>\n<div class=\"gatsby-highlight\" data-language=\"mermaid\"><pre class=\"language-mermaid\"><code class=\"language-mermaid\"><span class=\"token keyword\">graph</span> TD<span class=\"token punctuation\">;</span>\n    F<span class=\"token text string\">((F))</span><span class=\"token arrow operator\">--></span>B<span class=\"token text string\">((B))</span><span class=\"token punctuation\">;</span>\n    F<span class=\"token arrow operator\">--></span>G<span class=\"token text string\">((G))</span><span class=\"token punctuation\">;</span>\n    B<span class=\"token arrow operator\">--></span>A<span class=\"token text string\">((A))</span><span class=\"token punctuation\">;</span>\n    B<span class=\"token arrow operator\">--></span>D<span class=\"token text string\">((D))</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>After repeating this process you will reconstruct the whole tree:</p>\n<div class=\"gatsby-highlight\" data-language=\"mermaid\"><pre class=\"language-mermaid\"><code class=\"language-mermaid\"><span class=\"token keyword\">graph</span> TD<span class=\"token punctuation\">;</span>\n    F<span class=\"token text string\">((F))</span><span class=\"token arrow operator\">--></span>B<span class=\"token text string\">((B))</span><span class=\"token punctuation\">;</span>\n    F<span class=\"token arrow operator\">--></span>G<span class=\"token text string\">((G))</span><span class=\"token punctuation\">;</span>\n    B<span class=\"token arrow operator\">--></span>A<span class=\"token text string\">((A))</span><span class=\"token punctuation\">;</span>\n    B<span class=\"token arrow operator\">--></span>D<span class=\"token text string\">((D))</span><span class=\"token punctuation\">;</span>\n    D<span class=\"token arrow operator\">--></span>C<span class=\"token text string\">((C))</span><span class=\"token punctuation\">;</span>\n    D<span class=\"token arrow operator\">--></span>E<span class=\"token text string\">((E))</span><span class=\"token punctuation\">;</span>\n    G<span class=\"token arrow operator\">--></span>I<span class=\"token text string\">((I))</span><span class=\"token punctuation\">;</span>\n    G<span class=\"token arrow operator\">--></span>H<span class=\"token text string\">((H))</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>What you can do now is to wrap this process into an algorithm:</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token keyword\">def</span> <span class=\"token function\">reconstructTree</span><span class=\"token punctuation\">(</span>in_order<span class=\"token punctuation\">,</span> pre_order<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># if pre_order is empty - return None</span>\n    <span class=\"token keyword\">if</span> <span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>pre_order<span class=\"token punctuation\">)</span> <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">:</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">None</span>\n\n    <span class=\"token comment\"># extract first from pre_order as root</span>\n    root <span class=\"token operator\">=</span> Node<span class=\"token punctuation\">(</span>pre_order<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    pre_order <span class=\"token operator\">=</span> pre_order<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n\n    <span class=\"token comment\"># split in_order based on the root into:</span>\n    in_order_left <span class=\"token operator\">=</span> in_order<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span>in_order<span class=\"token punctuation\">.</span>index<span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    in_order_right <span class=\"token operator\">=</span> in_order<span class=\"token punctuation\">[</span>in_order<span class=\"token punctuation\">.</span>index<span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n    \n    <span class=\"token comment\"># split pre_order based on in_order_right &amp;in_order_left into:</span>\n    pre_order_left <span class=\"token operator\">=</span> pre_order<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">:</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>in_order_left<span class=\"token punctuation\">)</span><span class=\"token punctuation\">]</span>\n    pre_order_right <span class=\"token operator\">=</span> pre_order<span class=\"token punctuation\">[</span><span class=\"token operator\">-</span><span class=\"token builtin\">len</span><span class=\"token punctuation\">(</span>in_order_right<span class=\"token punctuation\">)</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span>\n\n    leftNode <span class=\"token operator\">=</span> reconstructTree<span class=\"token punctuation\">(</span>in_order_left<span class=\"token punctuation\">,</span> pre_order_left<span class=\"token punctuation\">)</span>\n    rightNode <span class=\"token operator\">=</span> reconstructTree<span class=\"token punctuation\">(</span>in_order_right<span class=\"token punctuation\">,</span> pre_order_right<span class=\"token punctuation\">)</span>\n\n    root<span class=\"token punctuation\">.</span>addLeft<span class=\"token punctuation\">(</span>leftNode<span class=\"token punctuation\">)</span>\n    root<span class=\"token punctuation\">.</span>addRight<span class=\"token punctuation\">(</span>rightNode<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> root\n</code></pre></div>\n<h3>5. Be careful about details</h3>\n<p>Once the code is written, check it twice. Pay attention to boundary cases.</p>\n<ul>\n<li>0-indexed vs 1-indexed?</li>\n<li>Double check the code where you add or substruct 1(if you do). Make sure that these boundaries are correct.</li>\n<li>Do you compare values anywhere? Check them - should a value be <em>greater</em> or <em>greater or equal</em>?</li>\n<li>Do you handle incorrect input?</li>\n</ul>\n<p>These were my learnings from this year Hackercup. If you ask me how far did I go, I tell you that I almost did it to round 3(not bad for the first try). Solve challenges and have fun! Good luck!</p>","frontmatter":{"title":"Facebook Hackercup. 5 tips","date":"August 11, 2018","description":null}},"previous":{"fields":{"slug":"/microservice-timeout/"},"frontmatter":{"title":"Microservices: Handling timeouts"}},"next":{"fields":{"slug":"/hackathon-availability/"},"frontmatter":{"title":"Hackathon: Parking availability"}}},"pageContext":{"id":"cf8821a9-8f27-51a3-afb1-5676377024a0","previousPostId":"26516ea5-a538-5da6-87c9-fe3cd528bfd8","nextPostId":"f58e025a-6715-5174-b501-60725e758cef"}},
    "staticQueryHashes": ["2841359383"]}